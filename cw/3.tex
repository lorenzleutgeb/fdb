\documentclass[a4paper,12pt]{article} 

\usepackage[a4paper, top=3cm, bottom=3cm, left=2cm, right=2cm]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{cmap}					% поиск в PDF
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english]{babel}     	% локализация и переносы
\usepackage{csquotes}
\usepackage{multicol}
\usepackage{tikz}
\usetikzlibrary{positioning}

\bibliographystyle{abbrv}

\usepackage[ruled,linesnumbered]{algorithm2e}

\newtheorem{claim}{Claim}

\newcommand{\cq}[1]{\ensuremath{\mathsf{CQ}_{#1}}}
\newcommand{\dbi}{\ensuremath{\mathbf{I}}}
\newcommand{\bigo}{\ensuremath{\mathcal{O}}}
\newcommand{\query}[3]{\ensuremath{{#1}({#2})\:{:}{-}\:{#3}}}
\newcommand{\rr}{\mathsf{RR}}
\newcommand{\ranf}{\mathsf{RANF}}
\newcommand{\srnf}{\mathsf{SRNF}}
\renewcommand{\phi}{\varphi}

\begin{document}

\begin{center}
{\LARGE\bfseries Foundations of Databases}\\[3mm]

{\Large Coursework 3}\\[5mm]

Lorenz Leutgeb\\\texttt{lorenz.leutgeb@stud-inf.unibz.it}\\[2mm]
Anastassiya Pustozerova\\\texttt{anastassiya.pustozerova@stud-inf.unibz.it}
\end{center}

\section{Evaluation of Special Types of Conjunctive Graph Queries}

We let $n = |\dbi|$.

\paragraph{Circle Query}{
\begin{algorithm}
	\KwIn{A positive non-zero integer $k$, a database instance (implicitly).}
	\KwOut{All the nodes, that lie on a circle of length at least $k$.}
	$R := \rho_{start \: \leftarrow\: 1, end\: \leftarrow\: 2}(edge)$\\
	\ForEach{$i \in \{1, \ldots, k - 1\}$}{
		$R := \rho_{end \:\leftarrow\:2} (\pi_{start, 2}(R \bowtie_{end = 1} edge))$\\
	}
	\Return{$\pi_{R.end}(\sigma_{R.start = R.end}R)$}
	\caption{$\mathsf{EvalCircle}(k)$}
	\label{alg:circle}
\end{algorithm}

Algorithm \ref{alg:circle} computes answers for $C_k$. The join in line 3 joins two relations of at most rows $n$ and results a relation of at most $n$ rows. This requires $\bigo(n \log n)$ steps. Note that the join in line 3 is executed $k - 1$ times, since it is inside a loop. The selection and projection in line 5 can be achieved by a single scan over $R$, thus are in $\bigo(n)$. We arrive at an overall time complexity in $\bigo(k \cdot n \cdot \log n)$ or rather $\bigo(k \cdot |\dbi| \cdot \log |\dbi|)$.
}

\paragraph{Star Query}{

\begin{algorithm}
\KwIn{A positive non-zero integer $k$, a database instance (implicitly).}
\KwOut{All the nodes, that are in the center of a star of at least $k$ nodes.}
\Return{$\Pi_{edge.1}$}
\caption{$\mathsf{EvalStar}(k, \dbi, \bar{c})$}
\label{alg:star}
\end{algorithm}

Time complexity of Algorithm \ref{alg:star} is in $\bigo(n) = \bigo(|\dbi|)$, a single scan over all edges suffices.
}

\paragraph{Spider-Web Query}{
% Copy what was on the blackboard.
\begin{algorithm}
	\KwIn{A positive non-zero integer $k$, a database instance (implicitly).}
	\KwOut{All the nodes, that lie on a circle of length at least $k$.}
	$R := \rho_{center \: \leftarrow\: 1, start\: \leftarrow\: 2}(edge) \bowtie \rho_{start\: \leftarrow\: 1, end\: \leftarrow\: 2}(edge)$\\
	\ForEach{$i \in \{1, \ldots, k - 1\}$}{
		$R := \rho_{end \:\leftarrow\:2} (\pi_{center, start, 2}(R \bowtie_{end = 1} edge))$\\
	}
	\Return{$\pi_{R.center}(\sigma_{R.start = R.end}R)$}
	\caption{$\mathsf{EvalSpiderWeb}(k)$}
	\label{alg:web}
\end{algorithm}

Consider Algorithm \ref{alg:web}: The time complexity of line 1 is in $\bigo(n \cdot \log n)$ and the analysis for lines 2-5 is similar to the $\mathsf{EvalCircle}$. We arrive at a time complexity in $\bigo(k \cdot n \cdot \log n)$ for the algorithm.
}

\paragraph{Clique Query}{The clique problem (for varying $k$) is known to be NP-complete (and a reduction from it is obvious). Time complexity of a guess-and-check algorithm is in $\bigo(n^k \cdot k^2)$ where $n^k$ is an upper bound for the number of possible cliques (subsets of $k$ nodes of the original graph) to guess and checking full connectedness for $k$ takes $k^2$ steps.}

\section{Evaluation of Conjunctive Queries with Unary Relation Symbols}

We address two classes of queries separately.

\paragraph{Relational Queries}{We consider relational queries of the form $\query{Q}{x_1, \dots, x_n}{L}$ where all elements of $L$ are relational atoms of arity one. Algorithm \ref{alg:rue} solves \textbf{query evaluation for these queries in polynomial time}. This stems from the fundamental insight that computing the union of two sets $R_1$ and $R_2$ can be achieved in time $\bigo(|R_1| \cdot |R_2|)$. The idea behind the algorithm is to start with the maximal set of answers possible $adom(\dbi)^n$ (without an explicit construction) and then mimimize this set using the relational atoms in the body of the query. For every variable $x_i$ ($1 \leq i \leq n$) in the head, an intermediate relation $R_{x_i}$ is introduced and initialized to equal $adom(\dbi)$. Then for every relational atom in which one of the free variables of the query occurs $R(x_i)$ ($1 \leq i \leq n$) the corresponding intermediate relation $R_{x_i}$ is filtered by $R$ accordingly by intersecting the two sets.

\begin{algorithm}
\KwIn{A boolean relational conjunctive query with unary relational symbols $\query{Q}{}{L}$ where $L$ are relational atoms, a database instance $\dbi$.}
\KwOut{\enquote{yes} iff $\{()\} = Q(\dbi)$, otherwise \enquote{no}.}
Let $\bar{x} = (x_1, \ldots x_n)$ contain all variables of $Q$ in arbitrary order.\\
\ForEach{$i \in \{1, \ldots, n\}$}{
	$R_{x_i} := adom(\dbi)$
}
\ForEach{$R(x_i) \in L$ with $i \in \{1, \ldots, n\}$}{
	%\If{$x = x_i$ with $i \in \{1, \dots, n\}$}{
	$R_{x_i} := R_{x_i} \cap R(\dbi)$\\
	\If{$R_{x_i} = \emptyset$}{\Return{\enquote{no}}}
	%}
	%\Else{
		%\Switch{
			% Intersect exitentially quantified variable domains until \emptyset (in this case return no)
		%	}
	%}
}
%\ForEach{$i \in \{1, \ldots, n\}$}{
%	\If{$R_{x_i} = \emptyset$}{\Return{\enquote{no}}}
%}
\Return{\enquote{yes}}
\caption{$\mathsf{RelUnaryEval}(Q,\dbi)$}
\label{alg:rue}
\end{algorithm}

The loop in lines 1-3 takes time in $\bigo(n \cdot |adom(\dbi)|)$, since it copies the active domain of the database instance $n$ times. The loop in lines 4-6 takes time in $\bigo(|L| \cdot |adom(\dbi)|^2)$: For every relational atom in the body of the query it computes an intersection, where the upper bound of the size of both intersected sets is the size of the active domain of the database instance. Finally, the containment checks in the loop in lines 7-11 take time in $\bigo(n \cdot |adom(\dbi)|)$ in the worst case. We observe that the loop in lines 4-6 dominates the time-behavior of the algorithm and relax $adom(\dbi)$ to $|\dbi|$ and $|L|$ as well as $n$ to $|Q|$, which yields an overall bound of $\bigo(|Q| \cdot |\dbi|^2)$. If we assume $Q$ (respectively $\dbi$) of constant size, we arrive at  $\bigo(|\dbi|^2)$ (respectively $\bigo(|Q|)$).
}

\paragraph{General Conjunctive Queries}{We consider the larger class of general conjunctive queries of the form $\query{Q}{x_1, \dots, x_n}{L,M}$ where all elements of $L$ are relational atoms of arity one and elements of $M$ are atoms over the built-in predicates $<$, $\leq$ and $\not =$.

We show that query evaluation for this class of queries is \textbf{NP-hard by reduction from} the well-known graph coloring problem.

\begin{center}
\textbf{Graph Coloring Problem}\\[1mm]
\begin{tabular}{rp{14cm}}
Given: & A directed graph $G = (V, E)$. \\
Question: & Is it possible to find a labeling $\alpha : V \rightarrow \{r, g, b\}$ with the property that for all $v, u \in V$ with $(v, u) \in E$ we have $\alpha(v) \not = \alpha(u)$.
\end{tabular}
\end{center}

Let $\dbi_{3} = \{ R(c_r), R(c_g), R(c_b) \}$, and $\mathcal{V}$ be an arbitrary infinite set of variable symbols and $\tilde{\cdot} : V \rightarrow \mathcal{V}$ be an injective function that maps a vertex $v \in V$ to an arbitrary variable symbol in $\mathcal{V}$.

Further, let $\query{Q_G}{}{L,M}$ be a (boolean) general conjunctive query where $L = \{ R(\tilde{v}) \mid v \in V \}$ and $M = \{ \tilde{v} \not = \tilde{u} \mid (v, u) \in E\}$.

We show that for a given directed graph $G$, a labeling $\alpha$ (with the property required by the Graph Coloring Problem) exists if-and-only-if $Q_G(\dbi_3)
 = \{ () \}$.

To see the if-direction: Let $\alpha$ by \dots

\section{Containment of Relational Conjunctive Queries without Self Joins}

Given two relational conjunctive queries without self joins $Q$ and $Q'$ and the question $Q \stackrel{\sqsubseteq} Q'$, our idea is to implement an algorithm that checks whether it is possible to find a query homomorphism $h : \mathcal{T}(Q') \rightarrow \mathcal{T}(Q)$ . By the Chandra-Merlin theorem $h$ exists if-and-only-if $Q \sqsubseteq Q'$ (note that we consider queries without built-ins).

In the lecture we saw two different definitions for query homomorphisms. The more strict one is defined in the slides (Part 4: Conjunctive Queries, slide 26). In the lecture we discovered a more general definition, where they key difference is how distinguished variables are handled.

Algorithm \ref{alg:homstrict} decides the existance of a homomorphism according to the stricter definition (see lines 16-21), and below we describe a procedure that addresses the more general setting:

\begin{algorithm}
\KwIn{Two relational queries without self join $\query{Q}{\bar{x}}{L}$ and $\query{Q'}{\bar{x'}}{L'}$.}
\KwOut{\enquote{yes} iff $Q \sqsubseteq Q'$, otherwise \enquote{no}.}
\ForEach{relational atom $R'(t'_1, \ldots, t'_n) \in L'$}{
$f := \bot$\\
\ForEach{relational atom $R(t_1, \ldots t_m) \in L$}{
\If{$R \not = R'$ or $n \not = m$}{\textbf{continue}}
$f := \top$\\
\ForEach{$i \in \{1, \ldots, n\}$}{
\Switch{on the type of $t'_i$}{
	\Case{constant}{
		\If{$t_i$ is a constant and $t_i = t'_i$}{\textbf{continue}}
		\Return{\enquote{no}}, since some constant would not be mapped to itself, violating $h(c) = c$.
	}
	\Case{distinguished variable in $Q'$}{
		\If{$t_i$ is a distinguished variable in $Q$ and $t_i = t'_i$}{\textbf{continue}}
		\Return{\enquote{no}}, since some distinguished variable would not be mapped to itself, violating $h(x) = x$.
	}
	\Case{non-distinguished variable}{
		// $t'_i$ may be mapped to other variables or constants.\\
		\textbf{continue}
	}
}
%\Return{\enquote{no}}, since there cannot be a homomorphism from $Q'$ to $Q$.

%\If{$t'_i$ is a variable that is not a distinguished variable in $Q'$}{\textbf{continue}, since the non-distinguished variable can mapped to other variables or constants.}
%\If{$t'_i$ is a constant and $t_i$ is a constant and $t_i \not = t'_i$}{\Return{\enquote{no}}, since for any homomorphism $h(c) = c$.}
%\If{$t'_i$ is a constant and $t_i$ is not a constant}{\Return{\enquote{no}}, since for any homomorphism $h(c) = c$.}
%\If{$t'_i$ is a distinguished variable and $t[i]$ is a distinguished variable and $t_i \not = t'_i$}{\Return{\enquote{no}}, since distinguished variables must map to themselves.}}
}
\textbf{break}\\
}
\If{$f = \bot$}{\Return{\enquote{no}}, since there is no relational atom over the relation $R$ in $L$, violating $h(L') \subseteq L$.}
}
\Return{\enquote{yes}}
\caption{$\mathsf{NoSelfJoinContained}(Q, Q')$}
\label{alg:homstrict}
\end{algorithm}

For the more general definition, we want to reduce the decision problem of the existence of a homomorphism $h : \mathcal{T}(Q') \rightarrow \mathcal{T}(Q)$ to term matching.

\begin{algorithm}
\KwIn{Two relational queries without self join $\query{Q}{\bar{x}}{L}$ and $\query{Q'}{\bar{x'}}{L'}$.}
\KwOut{\enquote{yes} iff $Q \sqsubseteq Q'$, otherwise \enquote{no}.}
$\mathcal{U} := \emptyset$\\

\ForEach{relational atom $R(t'_1, \ldots, t'_n) \in L'$}{
	\If{$R(t_1, \ldots, t_n) \not \in L$}{\Return{\enquote{no}}}
	$\mathcal{U} := \mathcal{U} \cup \{ t'_1 \approx t_1, \ldots, t'_n \approx t_n \}$ where $R(t_1, \ldots, t_n) \in L$\\
}

\While{$\mathcal{U} \not = \emptyset$}{
	Select an equation $s \approx t$ from $\mathcal{U}$.\\
	$\mathcal{U} := \mathcal{U} \setminus \{ s \approx t \}$\\
}
\caption{$\mathsf{NoSelfJoinContained}(Q, Q')$}
\label{alg:homgen}
\end{algorithm}

% Comment why we require distinguished variables to map to themselves. More general definition of a homomorphism is possible and we saw one in the lecture, but the one on the slides is stricter.
\end{document}